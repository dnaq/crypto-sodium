{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{- |
See the documentation in "Crypto.Sodium.PwHash".
-}
module Crypto.Sodium.PwHash.ScryptSalsa208Sha256
       ( -- * Constants
         saltBytes -- | Number of bytes in a 'Salt'.
       , hashedPasswordBytes -- | Number of bytes in a 'HashedPassword'.
       , hashedPasswordPrefix -- | Prefix of a 'HashedPassword'.
       , opsLimitInteractive -- | Safe base line for 'OpsLimit'.
       , opsLimitSensitive -- | 'OpsLimit' for highly sensitive data.
       , memLimitInteractive -- | Safe base line for 'MemLimit'.
       , memLimitSensitive -- | 'MemLimit' for highly sensitive data.

       -- * Types
       , OpsLimit (..) -- | Maximum amount of computations to perform.
                       -- Raising this number will make the calling function
                       -- require more CPU cycles to compute a key.
       , MemLimit (..) -- | Maximum amount of RAM that the calling function
                       -- will use, in bytes. It is highly recommended to allow
                       -- the function to use at least 16 megabytes.
       , Salt -- | Unpredictable 'Salt' for key derivation.
       , mkSalt -- | Smart constructor for 'Salt'. Verifies that the length of
                -- the parameter is 'saltBytes'.
       , unSalt -- | Returns the contents of a 'Salt'.
       , HashedPassword -- | An ASCII-encoded NULL-terminated string that
                        -- includes:
                        --
                        -- * The result of a memory-hard, CPU-intensive function
                        --   applied to a password
                        -- * The automatically generated salt used for the
                        --   computation
                        -- * The other parameters needed to verify the password,
                        --   'OpsLimit' and 'MemLimit'.
       , mkHashedPassword -- | Smart constructor for 'HashedPassword'.
                          -- Verifies that the length of the parameter is
                          -- 'hashedPasswordBytes'.
       , unHashedPassword -- | Returns the contents of a 'HashedPassword'.

         -- * Salt Generation
       , randomSalt -- | Randomly generates a 'Salt'.

         -- * Key Derivation
       , deriveKey -- | Derives a key of a certain length from a
                   -- password and a 'Salt'.
                   -- Returns 'Nothing' if 'deriveKey' couldn't complete
                   -- successfully, usually because the operating system
                   -- refused to allocate the requested amount of memory.

         -- * Password Hashing
       , hashPassword -- | Derives a 'HashedPassword' from a password
                      -- with a randomly generated 'Salt'.
                      -- Returns 'Nothing' if it couldn't complete successfully,
                      -- usually because the operating system refused to
                      -- allocate the requested amount of memory.
       , verifyPassword -- | Verifies that a 'HashedPassword' is a valid
                        -- password verification string (as generated by 'hashPassword')
                        -- for a password.
       ) where

import           Crypto.Sodium.Internal  (createWithResult, mkHelper)
import           Crypto.Sodium.Random    (randomBytes)
import           Crypto.Sodium.SecureMem (SecureMem)
import qualified Crypto.Sodium.SecureMem as SM

import           Data.ByteString         (ByteString)
import qualified Data.ByteString.Unsafe  as B
import           Data.Hashable           (Hashable)
import           Data.Word               (Word8)
import           Foreign.C.String        (CString)
import           Foreign.C.Types         (CChar, CInt (..), CSize (..),
                                          CULLong (..))
import           Foreign.Ptr             (Ptr)
import           System.IO.Unsafe        (unsafeDupablePerformIO)

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_saltbytes"
  c_crypto_pwhash_scryptsalsa208sha256_saltbytes :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_strbytes"
  c_crypto_pwhash_scryptsalsa208sha256_strbytes :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_strprefix"
  c_crypto_pwhash_scryptsalsa208sha256_strprefix :: CString

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_opslimit_interactive"
  c_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_memlimit_interactive"
  c_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive"
  c_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive"
  c_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive :: CSize

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256"
  c_crypto_pwhash_scryptsalsa208sha256 :: Ptr Word8 -> CULLong -> Ptr CChar -> CULLong -> Ptr CChar -> CULLong -> CSize -> IO CInt

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_str"
  c_crypto_pwhash_scryptsalsa208sha256_str :: Ptr Word8 -> Ptr CChar -> CULLong -> CULLong -> CSize -> IO CInt

foreign import ccall unsafe "crypto_pwhash_scryptsalsa208sha256_str_verify"
  c_crypto_pwhash_scryptsalsa208sha256_str_verify :: Ptr CChar -> Ptr CChar -> CULLong -> IO CInt

saltBytes :: Int
saltBytes = fromIntegral c_crypto_pwhash_scryptsalsa208sha256_saltbytes

hashedPasswordBytes :: Int
hashedPasswordBytes = fromIntegral c_crypto_pwhash_scryptsalsa208sha256_strbytes

hashedPasswordPrefix :: ByteString
hashedPasswordPrefix =
  unsafeDupablePerformIO $
  B.unsafePackCString c_crypto_pwhash_scryptsalsa208sha256_strprefix

newtype OpsLimit = OpsLimit { unOpsLimit :: CULLong } deriving (Eq, Show, Ord)

opsLimitInteractive :: OpsLimit
opsLimitInteractive =
  OpsLimit $ fromIntegral c_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive

opsLimitSensitive :: OpsLimit
opsLimitSensitive =
  OpsLimit $ fromIntegral c_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive

newtype MemLimit = MemLimit { unMemLimit :: CSize } deriving (Eq, Show, Ord)

memLimitInteractive :: MemLimit
memLimitInteractive =
  MemLimit c_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive

memLimitSensitive :: MemLimit
memLimitSensitive =
  MemLimit c_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive

newtype Salt = Salt { unSalt :: ByteString } deriving (Eq, Show, Ord, Hashable)

mkSalt :: ByteString -> Maybe Salt
mkSalt = mkHelper saltBytes Salt

newtype HashedPassword = HashedPassword { unHashedPassword :: ByteString }
                       deriving Show

mkHashedPassword :: ByteString -> Maybe HashedPassword
mkHashedPassword = mkHelper hashedPasswordBytes HashedPassword

randomSalt :: IO Salt
randomSalt = Salt <$> randomBytes saltBytes

deriveKey :: Int -- ^ Length of the key to derive.
          -> ByteString -- ^ Password for key derivation.
          -> Salt
          -> OpsLimit -- ^ Number of computations to perform.
          -> MemLimit -- ^ Amount of memory to use.
          -> Maybe SecureMem
deriveKey len pw (Salt s) (OpsLimit ol) (MemLimit ml) =
  unsafeDupablePerformIO $
  B.unsafeUseAsCStringLen pw $ \(ppw, pwLen) ->
  B.unsafeUseAsCString s $ \ps -> do
    (k, r) <- SM.create' len $ \pk ->
      c_crypto_pwhash_scryptsalsa208sha256 pk (fromIntegral len) ppw (fromIntegral pwLen) ps ol ml
    return $ if r == 0 then Just k else Nothing

hashPassword :: OpsLimit -- ^ Number of computations to perform.
             -> MemLimit -- ^ Amount of memory to use.
             -> ByteString -- ^ Password to hash.
             -> IO (Maybe HashedPassword)
hashPassword (OpsLimit ol) (MemLimit ml) pw = do
  (hpw, r) <- createWithResult hashedPasswordBytes $ \pout ->
    B.unsafeUseAsCStringLen pw $ \(ppw, pwLen) ->
    c_crypto_pwhash_scryptsalsa208sha256_str pout ppw (fromIntegral pwLen) ol ml
  return $ if r == 0
           then Just $ HashedPassword hpw
           else Nothing

verifyPassword :: ByteString -- ^ Password to verify.
               -> HashedPassword -- ^ Password verifier to verify the password against.
               -> Bool
verifyPassword pw (HashedPassword hpw) =
  (==0) $
  unsafeDupablePerformIO $
  B.unsafeUseAsCString hpw $ \phpw ->
  B.unsafeUseAsCStringLen pw $ \(ppw, pwLen) ->
  c_crypto_pwhash_scryptsalsa208sha256_str_verify phpw ppw (fromIntegral pwLen)
