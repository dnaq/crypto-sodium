{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TemplateHaskell   #-}
module Tests.Sodium.Box.Curve25519Xsalsa20Poly1305 where

import           Crypto.Sodium.Box.Curve25519Xsalsa20Poly1305
import           Crypto.Sodium.SecureMem

import           Tests.Sodium.Common

import           Data.ByteString                              (ByteString)
import qualified Data.ByteString                              as B
import           Data.Maybe
import           Data.Word
import           Test.QuickCheck.Monadic                      as QM
import           Test.Tasty
import           Test.Tasty.HUnit
import           Test.Tasty.QuickCheck
import           Test.Tasty.TH

mkSeed' :: [Word8] -> Seed
mkSeed' = fromJust . mkSeed . fromByteString . B.pack

mkNonce' :: [Word8] -> Nonce
mkNonce' = fromJust . mkNonce . B.pack

mkSecretKey' :: [Word8] -> SecretKey
mkSecretKey' = fromJust . mkSecretKey . fromByteString . B.pack

mkPublicKey' :: [Word8] -> PublicKey
mkPublicKey' = fromJust . mkPublicKey . B.pack

instance Arbitrary Seed where
    arbitrary = mkSeed' <$> vector seedBytes

instance Arbitrary Nonce where
    arbitrary = mkNonce' <$> vector nonceBytes

instance Arbitrary (PublicKey, SecretKey) where
    arbitrary = keypairFromSeed <$> arbitrary

case_seedBytes :: Assertion
case_seedBytes = 32 @=? seedBytes

case_publicKeyBytes :: Assertion
case_publicKeyBytes = 32 @=? publicKeyBytes

case_secretKeyBytes :: Assertion
case_secretKeyBytes = 32 @=? secretKeyBytes

case_precomputedKeyBytes :: Assertion
case_precomputedKeyBytes = 32 @=? precomputedKeyBytes

case_nonceBytes :: Assertion
case_nonceBytes = 24 @=? nonceBytes

prop_mkPublicKey :: (PublicKey, SecretKey) -> Bool
prop_mkPublicKey (pk, _) = pk == fromJust (mkPublicKey $ unPublicKey pk)

prop_mkSecretKey :: (PublicKey, SecretKey) -> Bool
prop_mkSecretKey (_, sk) = sk == fromJust (mkSecretKey $ unSecretKey sk)

prop_mkSeed :: Seed -> Bool
prop_mkSeed s = s == fromJust (mkSeed $ unSeed s)

prop_mkNonce :: Nonce -> Bool
prop_mkNonce n = n == fromJust (mkNonce $ unNonce n)

prop_mkPrecomputedKey :: (PublicKey, SecretKey) -> (PublicKey, SecretKey) -> Bool
prop_mkPrecomputedKey (_, ourSk) (theirPk, _) =
  let k = precompute ourSk theirPk
  in k == fromJust (mkPrecomputedKey $ unPrecomputedKey k)

prop_randomKeypairNonce :: ByteString -> Property
prop_randomKeypairNonce m = monadicIO $ do
  (ourPk, ourSk) <- run randomKeypair
  (theirPk, theirSk) <- run randomKeypair
  n <- run randomNonce
  QM.assert $ Just m == open theirSk ourPk n (seal ourSk theirPk n m)

prop_randomSeedNonce :: ByteString -> Property
prop_randomSeedNonce m = monadicIO $ do
  (ourPk, ourSk) <- keypairFromSeed <$> run randomSeed
  (theirPk, theirSk) <- keypairFromSeed <$> run randomSeed
  n <- run randomNonce
  QM.assert $ Just m == open theirSk ourPk n (seal ourSk theirPk n m)

prop_seal_open :: (PublicKey, SecretKey) -> (PublicKey, SecretKey) -> Nonce -> ByteString -> Bool
prop_seal_open (ourPk, ourSk) (theirPk, theirSk) n m =
  let c = seal ourSk theirPk n m
      m' = open theirSk ourPk n c
  in Just m == m'

prop_seal_open_precomputed :: (PublicKey, SecretKey) -> (PublicKey, SecretKey) -> Nonce -> ByteString -> Bool
prop_seal_open_precomputed (ourPk, ourSk) (theirPk, theirSk) n m =
    let ourK = precompute ourSk theirPk
        theirK = precompute theirSk ourPk
        c = sealPrecomputed ourK n m
        m' = openPrecomputed theirK n c
    in Just m == m'

prop_seal_eq_seal_precomputed :: (PublicKey, SecretKey) -> (PublicKey, SecretKey) -> Nonce -> ByteString -> Bool
prop_seal_eq_seal_precomputed (ourPk, ourSk) (theirPk, theirSk) n m =
    let ourK = precompute ourSk theirPk
        theirK = precompute theirSk ourPk
        c = seal ourSk theirPk n m
        c' = sealPrecomputed ourK n m
        c'' = sealPrecomputed theirK n m
    in c == c' && c' == c''

prop_seal_open_tamper :: (PublicKey, SecretKey)
                      -> (PublicKey, SecretKey)
                      -> Nonce -> ByteString -> Int -> Positive Word8 -> Bool
prop_seal_open_tamper (ourPk, ourSk) (theirPk, theirSk) n m i (Positive w) =
    let c = seal ourSk theirPk n m
        c' = tamperAt i w c
    in isNothing $ open theirSk ourPk n c'

prop_seal_open_precomputed_tamper :: (PublicKey, SecretKey)
                                  -> (PublicKey, SecretKey)
                                  -> Nonce -> ByteString
                                  -> Int -> Positive Word8 -> Bool
prop_seal_open_precomputed_tamper (ourPk, ourSk)
                                  (theirPk, theirSk)
                                  n m i (Positive w) =
    let ourK = precompute ourSk theirPk
        theirK = precompute theirSk ourPk
        c = sealPrecomputed ourK n m
        c' = tamperAt i w c
    in isNothing $ openPrecomputed theirK  n c'

case_test_vector_1 :: Assertion
case_test_vector_1 = do
  let alicesk = mkSecretKey'
                [0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,
                 0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,
                 0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a,
                 0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]
      bobpk = mkPublicKey'
              [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,
               0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,
               0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d,
               0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]
      nonce = mkNonce'
              [0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73,
               0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6,
               0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37]
      m = B.pack [0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5,
                  0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b,
                  0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4,
                  0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc,
                  0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a,
                  0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29,
                  0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4,
                  0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31,
                  0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d,
                  0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57,
                  0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a,
                  0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde,
                  0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd,
                  0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52,
                  0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40,
                  0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64,
                  0x5e,0x07,0x05]
      c = seal alicesk bobpk nonce m
      k = precompute alicesk bobpk
      cpre = sealPrecomputed k nonce m
      cexp = B.pack [0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,
                     0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9,
                     0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,
                     0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
                     0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,
                     0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
                     0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,
                     0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
                     0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,
                     0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
                     0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,
                     0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
                     0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,
                     0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
                     0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,
                     0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
                     0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,
                     0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
                     0xe3,0x55,0xa5]
  cexp @=? c
  cexp @=? cpre

case_test_vector_2 :: Assertion
case_test_vector_2 = do
  -- corresponding to tests/box2.c and tests/box4.cpp from NaCl
  let bobsk = mkSecretKey'
              [0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,
               0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,
               0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,
               0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]
      alicepk = mkPublicKey'
                [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,
                 0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,
                 0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,
                 0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]
      nonce = mkNonce'
              [0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73,
               0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6,
               0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37]
      c = B.pack [0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,
                  0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9,
                  0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,
                  0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
                  0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,
                  0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
                  0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,
                  0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
                  0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,
                  0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
                  0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,
                  0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
                  0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,
                  0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
                  0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,
                  0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
                  0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,
                  0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
                  0xe3,0x55,0xa5]
      mexp = B.pack [0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5,
                     0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b,
                     0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4,
                     0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc,
                     0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a,
                     0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29,
                     0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4,
                     0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31,
                     0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d,
                     0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57,
                     0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a,
                     0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde,
                     0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd,
                     0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52,
                     0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40,
                     0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64,
                     0x5e,0x07,0x05]
      m = open bobsk alicepk nonce c
      k = precompute bobsk alicepk
      m_pre = openPrecomputed k nonce c
  Just mexp @=? m
  Just mexp @=? m_pre

tests :: TestTree
tests = $(testGroupGenerator)
